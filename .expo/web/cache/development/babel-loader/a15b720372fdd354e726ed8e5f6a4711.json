{"ast":null,"code":"export var snapPoint = function () {\n  var _f = function _f(value, velocity, points) {\n    var point = value + 0.2 * velocity;\n    var deltas = points.map(function (p) {\n      return Math.abs(point - p);\n    });\n    var minDelta = Math.min.apply(null, deltas);\n    return points.filter(function (p) {\n      return Math.abs(point - p) === minDelta;\n    })[0];\n  };\n  _f._closure = {};\n  _f.asString = \"function snapPoint(value,velocity,points){var point=value+0.2*velocity;var deltas=points.map(function(p){return Math.abs(point-p);});var minDelta=Math.min.apply(null,deltas);return points.filter(function(p){return Math.abs(point-p)===minDelta;})[0];}\";\n  _f.__workletHash = 3848343866657;\n  _f.__location = \"D:\\\\nouveaux projet\\\\ajout panier buttonsheet\\\\node_modules\\\\@gorhom\\\\bottom-sheet\\\\node_modules\\\\react-native-redash\\\\lib\\\\module\\\\Physics.js (1:21)\";\n  global.__reanimatedWorkletInit(_f);\n  return _f;\n}();","map":{"version":3,"sources":["Physics.ts"],"names":["snapPoint","value","velocity","points","point","deltas","map","p","Math","abs","minDelta","min","apply","filter"],"mappings":"AAIA,OAAO,IAAMA,SAAAA;EAAAA,qBACXC,KADuB,EAEvBC,QAFuB,EAGvBC,MAHuB,EAIZ;IAEX,IAAMC,KAAK,GAAGH,KAAK,GAAG,GAAA,GAAMC,QAA5B;IACA,IAAMG,MAAM,GAAGF,MAAM,CAACG,GAAPH,CAAW,UAACI,CAAD,EAAA;MAAA,OAAOC,IAAI,CAACC,GAALD,CAASJ,KAAK,GAAGG,CAAjBC,CAAP;IAAA,CAAXL,CAAf;IACA,IAAMO,QAAQ,GAAGF,IAAI,CAACG,GAALH,CAASI,KAATJ,CAAe,IAAfA,EAAqBH,MAArBG,CAAjB;IACA,OAAOL,MAAM,CAACU,MAAPV,CAAc,UAACI,CAAD,EAAA;MAAA,OAAOC,IAAI,CAACC,GAALD,CAASJ,KAAK,GAAGG,CAAjBC,CAAAA,KAAwBE,QAA/B;IAAA,CAAdP,CAAAA,CAAuD,CAAvDA,CAAP;EACD,CAVM;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;AAAA","sourcesContent":["/**\n * @summary Select a point where the animation should snap to given the value of the gesture and it's velocity.\n * @worklet\n */\nexport const snapPoint = (\n  value: number,\n  velocity: number,\n  points: ReadonlyArray<number>\n): number => {\n  \"worklet\";\n  const point = value + 0.2 * velocity;\n  const deltas = points.map((p) => Math.abs(point - p));\n  const minDelta = Math.min.apply(null, deltas);\n  return points.filter((p) => Math.abs(point - p) === minDelta)[0];\n};\n"]},"metadata":{},"sourceType":"module"}